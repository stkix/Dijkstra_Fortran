# Dijkstra_Fortran

このプログラムはメインプログラムとサブプログラム（サブルーチンと副関数）に分かれています。

まずメインプログラムについて説明します。メインプログラムには最初に整数としてnum_vertices、num_edges、i、start_vertex、end_vertex、count、unitを定義しました。その後、実数型変数の動的割り付けを用いてx、y、weight、distを定義しました。（ここでx(:)の:をn（整数）とすると、x、y、distにはそれぞれn個の変数が存在し、weightは2n個の変数が存在します。）次に整数型変数の動的割り付けを用いてpreviousを定義しました。（ここでprevious(:)の:をn（整数）とすると、previousはn個の変数が存在します。）

ここでそれぞれの変数の用途について説明します。まずnum_verticesとは頂点の数を収納しており、num_edgesは頂点と頂点をつなぐ辺の数を収納しています。そしてstart_vertexは始点、end_vertexは終点を収納しています。ここでx、yは各頂点の(x, y)座標を収納しており、weightはある頂点からある頂点までの距離を収納しています。（例えば点(x1, y1)（頂点1）から点(x2, y2)（頂点2）を繋いだ辺を辺1として定義する時に、weight(1, 2)とは頂点1から頂点2までの距離であり、つまり辺1の長さです。）（グラフ理論においてある点からある点までに行く時の負荷を重みweightといいます。）次にdistについてですが、distは各頂点における始点からその点までの最短距離を収納しています。最後にpreviousに関しては、その変数には各頂点における始点からの最短距離の直前の頂点を示す配列です。

次に変数定義後のプログラムについて説明します。ここでまずはopenを用いて頂点の情報が記載してあるinp.txtファイルを開き、そのstatusをoldにし、actionをreadに指定しました。その後、頂点の数であるnum_verticesを初期化し、num_verticesを0にしました。その後、do構文を用いてinp.txt内に存在する頂点の数を数えました。

ここで具体的にread(10, *, iostat=count)やif(count==0)以後について説明します。まずはiostatについて、ファイルのデータが無事に読み込むことができた場合、iostat=0となり、データを読み取る際以後のデータが存在せずに読み込むことができないなどのエラーが発生した場合、iostatは0以外の数字となります。つまりiostat≠0となります。ここで一回データを読み込むことができれば、num_verticesは+1されます。ここでもし最後にデータが読み込まれ、その以後にデータが存在しなければiostat≠0となり、do構文が終了します。このdo構文が終了した後のnum_verticesにはinp.txtに存在する頂点の数が含まれています。

次にrewindを用いてinp.txtを初期化し、inp.txtを最初の値から読み込むことができるステータスまで持っていきます。ここでさっきのプログラムによりnum_verticesには全頂点の数が収納されており、これを用いてx、y、weight、dist、previousの配列を割り当てます。次にdo構文を用いてinp.txt内に存在する座標(x, y)を読み込みました。その後、inp.txtを閉じました。

その後、頂点と頂点をつなぐ辺の数を設定するためにターミナルから辺の数を入力しました。もしここで辺数が1以下であればプログラムを終了し、ターミナルから「エラー：辺数は1以上にしなければならない」と表示されます。以後では辺数は1以上であるとして説明を進めます。ここでcallを用いてサブルーチンread_edgesを呼び出し、辺の情報を入力します。（具体的なサブルーチンの説明はその後で行いますが、ここではinp.txtの一行目には二つの実数が存在し、その二つの実数が頂点1（第一行に存在する場合は頂点1、第二行であれば頂点2であるとプログラムが認識する）のx、y座標を表しています。ここで辺1についてターミナルから1（スペースあり）2と入力すると、辺1は頂点1と頂点2を結んだ辺であると定義することができます。）辺の情報の入力が完了した後に、始点と終点をターミナルから入力します。

ここで始点の入力について説明します。do構文を用いてまずはターミナルから「始点を入力してください（1から（num_vertices(頂点の数)）の範囲まで）」が表示され、そこで始点を入力します。もしここで始点を収納する変数start_vertexが1以上でnum_vertices以下であれば、if構文やexitを用いてdo構文を脱出します。もしstart_vertexが1未満でnum_verticesを越えた場合はターミナルから「エラー: 無効な始点番号が指定されました」と表示されます。ここで終点は始点と同じようなdo構文、if構文やexitを用いており、もしエラーが起きた場合は「エラー: 無効な終点番号が指定されました」とターミナルから表示されます。

次にcallを用いてサブルーチンdijkstra_algorithmを呼び出し、ダイクストラ法による最短経路問題を解きました。（具体的なサブルーチンの説明はその後で行いますが、ダイクストラ法を実行した結果はdistやpreviousに反映されます。）次に実行した結果を表示します。ここでdistは始点から各頂点までの最短経路距離を収納しており、do構文を用いて始点から各頂点までの最短経路距離をターミナルから表示されます。

次に関数副プログラムwrite_shortest_pathを用いて始点からある点まで最短経路の配列を作り、do構文を用いてターミナルに表示されます。そして終点のみの情報をターミナルから表示できるようにします。メインプログラムの最後はx、y、weight、dist、previousのメモリを解放するために、deallocateを使いました。

次にcontainsを用いてメインプログラムとサブプログラムを一つのプログラムにまとめました。ここでこのプログラムで使ったサブルーチンや関数副プログラムについて説明します。

辺の情報を入力するサブルーチンread_edgesについて、ここで入力する整数としてnum_edges、num_verticesがあり、一般的な整数としてi、start_vertex、end_vertex、入力する配列型実数としてx、y、出力される配列型実数としてweight、一般的な実数としてinfinityが宣言されます。まずは重み配列weightの初期値として無限大を設定するためにinfinity =1.0e30（1.0×10^30）としました。

まずターミナルから「各辺の始点と終点を入力してください:」が表示され、その後do構文を用いて辺1、辺2以後の辺と頂点1、頂点2などの頂点との関係をターミナルから入力します。具体的には例えば辺3においてターミナルから3（スペースあり）4と入力した場合、それは頂点3と頂点4を繋いだ線分が辺3であることを意味します。ここでもし入力した頂点が1未満か、その頂点の番号がnum_verticesを越えた場合はエラーが起こり、その時ターミナルから「エラー: 無効な頂点番号が指定されました」と表示されます。

エラーが起こらなかった場合はターミナルから「辺iの重み（x座標とy座標の距離）は…である」と表示され、実際各頂点間の距離を計算し、その辺の長さ（重み）をweightに収納しました。

次にダイクストラ法のサブルーチンdijkstra_algorithmについて説明します。ここで入力する整数としてnum_edges、start_vertexがあり、入力する実数としてweight、出力される配列型の実数としてdist、出力される配列型の整数としてprevious、配列型の論理型変数としてvisited、整数としてi、j、current_vertex、実数としてinfinityが宣言されています。まずは最短距離distの初期値として無限大を設定するためにinfinity =1.0e30（1.0×10^30）としました。その後配列visited、dist、previousの配列数をallocateで決定し、そしてvisited全体をfalse、previous全体を-1にしました。

ここでvisitedやpreviousの用途について説明します。visitedについては頂点においてその頂点が確定されているかどうかを決める時に使われます。visited=.false.の時はその頂点は未確定であることを意味し、visited=.true.の時はその頂点は確定済みであることを意味します。次にpreviousについては、そこには各頂点の最短経路における直前の頂点の索引（インデックス）が収納されています。

例えばprevious配列が[-1, 1, 2, 2, 3]である場合、頂点1のpreviousが-1であることは、その前の頂点が存在しないことを意味します。頂点2のpreviousが1であることは、頂点2の前の頂点が頂点1であることを意味します。頂点3のpreviousが2であることは、頂点3の前の頂点が頂点2であることを意味します。頂点4のpreviousが2であることは、頂点4の前の頂点が頂点2であることを意味します。頂点5のpreviousが3であることは、頂点5の前の頂点が頂点3であることを意味します。そのため、頂点をすべて未確定に設定するためにvisited=.false.にし、すべての頂点においてその直前の頂点が存在するかどうかが不明であるため、すべて頂点のpreviousを-1に設定します。

以降はダイクストラ法を実行します。ここでdo構文を使用します。まずは始点の最短距離を0にするため、dist(start_vertex) = 0.0にしました。その後条件（条件1）（未確定の頂点かつ（現在の頂点が0または未確定の点までの最短距離の長さが現在の点までの最短距離の長さよりも小さい））を満たした時、その未確定の頂点を確定し、その点を現在の点とします。その操作はすべての未確定の点のうち距離が一番短い点を確定するための操作です。グラフ理論においては、その操作は現在加算された重みが一番小さい点を確定することである。

次にその確定した点から未確定の点までの距離を計算し、もしそれが現時点における最短距離である場合、それが新しい最短距離として更新します。そしてその直前の頂点をpreviousに保存します。この時の条件（条件2）は（未確定の頂点かつ（（現在の点までの距離）+（現在の点から未確定の点までの距離）が現在の点よりも小さい））です。この二つの条件に関しては例えば頂点5まで調べる時に条件1に関してすべての未確定の点に対して計算を行い、その後条件2においてもすべての未確定の点に対して計算を行います。そのことからこのサブルーチンにおいてはdo構文の中に二つのdo構文が存在します。

最後に関数副プログラムwrite_shortest_pathについて説明します。ここでは入力する整数としてvertex、入力する配列型整数としてprevious、整数のnext_vertex、i、num_vertices、配列型整数としてpathが宣言されています。vertexとは最短経路を求める終点の索引（インデックス）で、previousとは各頂点の最短経路における直前の頂点の索引（インデックス）、pathは各頂点まで最短経路の頂点が収納されています。

previousの数の大きさ（previousのサイズ）をnum_verticesに収納します。そしてpathのサイズはallocateを用いてそのサイズの大きさをnum_verticesにします。その後next_vertex=vertexとし、path(1)=next_vertexとしました。そして次にdo構文を用いてpathの配列を求めました。具体的にはpreviousにおいて-1が出現した時、その場合はその頂点の直前の頂点が存在せず、do構文が終了することを条件にして、next_vertex=previous(next_vertex)とし、そのpath配列にそのnext_vertexを収納します。

ここでprevious=(-1, 1, 2, 3, 4)とした場合、頂点5に注目すると、最初はnext_vertex=5とし、path(1)=5としました。その後next_vertex= previous(5)=4より、path(2)=4となります。このような操作を繰り返すと、path=(5, 4, 3, 2, 1)となります。これは頂点5までは、頂点1、頂点2、頂点3、頂点4、頂点5の順番が最短経路となります。しかしここで見ると順番が大きい順から小さい順まで配列が並んでおり、一見するとわかりにくい。そのためその関数副プログラムの中にpathを逆転するサブルーチンを入れました。

そのサブルーチンについて説明すると、配列の最初と最後の数値を入れ替えて、そして左から二番目の数値と右から二番目を入れ替える操作などを行います。そうすることによって、配列の前後を入れ替えることができます。つまりさっきのpathの例をそのサブルーチンを用いて逆転すると、path=(1, 2, 3, 4, 5)となります。
